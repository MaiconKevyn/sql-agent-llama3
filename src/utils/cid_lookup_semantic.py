"""
CIDLookup com busca sem√¢ntica - mant√©m mesma interface, adiciona intelig√™ncia.
Mudan√ßas m√≠nimas no c√≥digo existente, m√°ximo ganho de funcionalidade.
"""

import pandas as pd
import numpy as np
from typing import Optional, Tuple, List, Dict
import re
from difflib import SequenceMatcher

# Tentar importar sentence-transformers para embeddings
try:
    from sentence_transformers import SentenceTransformer

    EMBEDDINGS_AVAILABLE = True
except ImportError:
    EMBEDDINGS_AVAILABLE = False
    print("‚ö†Ô∏è sentence-transformers n√£o dispon√≠vel. Usando busca por similaridade textual.")


class CIDLookup:
    """
    CIDLookup melhorado com busca sem√¢ntica.
    Mant√©m a mesma interface, mas adiciona intelig√™ncia sem√¢ntica.
    """

    def __init__(self, file_path: str = 'CID-10-CAPITULOS.CSV'):
        """
        Inicializa com busca sem√¢ntica se dispon√≠vel, sen√£o usa similarity textual.
        """
        self.cid_df = None
        self.cid_codes_df = None
        self.embeddings = None
        self.model = None

        # Base hardcoded como √∫ltimo fallback (mant√©m compatibilidade)
        self.hardcoded_chapters = self._build_hardcoded_base()

        # Tentar carregar base CID-10 completa
        self._load_cid_database()

        # Inicializar busca sem√¢ntica se dispon√≠vel
        if EMBEDDINGS_AVAILABLE and self.cid_codes_df is not None:
            self._initialize_semantic_search()

        print(f"üìö CIDLookup inicializado:")
        print(f"   üîç Semantic search: {'‚úÖ' if self.model else '‚ùå'}")
        print(f"   üìã Base CID completa: {'‚úÖ' if self.cid_codes_df is not None else '‚ùå'}")
        print(f"   üîÑ Fallback hardcoded: ‚úÖ ({len(self.hardcoded_chapters)} categorias)")

    def _build_hardcoded_base(self) -> Dict[str, Tuple[str, str]]:
        """Mant√©m base hardcoded como fallback - exatamente igual ao anterior."""
        return {
            # Respirat√≥rias
            'respirat√≥rias': ('J00', 'J99'), 'respirat√≥ria': ('J00', 'J99'),
            'respiratorio': ('J00', 'J99'), 'pulm√£o': ('J00', 'J99'),
            'pneumonia': ('J12', 'J18'), 'asma': ('J45', 'J46'),
            'bronquite': ('J20', 'J42'), 'gripe': ('J09', 'J11'),

            # Cardiovasculares
            'cardiovasculares': ('I00', 'I99'), 'card√≠acas': ('I00', 'I99'),
            'cora√ß√£o': ('I00', 'I99'), 'infarto': ('I21', 'I22'),
            'avc': ('I60', 'I69'), 'hipertens√£o': ('I10', 'I15'),

            # Outras categorias principais
            'c√¢ncer': ('C00', 'D49'), 'cancer': ('C00', 'D49'),
            'diabetes': ('E10', 'E14'), 'renal': ('N00', 'N99'),
            'digestivas': ('K00', 'K95'), 'mentais': ('F00', 'F99'),
            'neurol√≥gicas': ('G00', 'G99'), 'end√≥crinas': ('E00', 'E89')
        }

    def _load_cid_database(self):
        """
        Carrega base CID-10 completa ou cria uma simulada.
        """
        try:
            # Tentar carregar arquivo real
            self.cid_df = pd.read_csv('CID-10-CAPITULOS.CSV', delimiter=';', encoding='latin-1')
            if not self.cid_df.empty:
                self.cid_df.columns = [col.upper() for col in self.cid_df.columns]
                print("‚úÖ Arquivo CID-10-CAPITULOS carregado com sucesso")
        except:
            print("‚ö†Ô∏è Arquivo CID-10-CAPITULOS n√£o encontrado, usando base simulada")

        # Criar ou carregar base de c√≥digos espec√≠ficos para busca sem√¢ntica
        self.cid_codes_df = self._create_cid_codes_database()

    def _create_cid_codes_database(self) -> pd.DataFrame:
        """
        Cria base de c√≥digos CID espec√≠ficos com descri√ß√µes.
        Simula uma base real ou carrega de arquivo.
        """

        # Base simulada com c√≥digos reais CID-10 mais comuns
        cid_data = [
            # Respirat√≥rias (J00-J99)
            {"codigo": "J00", "descricao": "Nasofaringite aguda (resfriado comum)"},
            {"codigo": "J06", "descricao": "Infec√ß√µes agudas das vias a√©reas superiores"},
            {"codigo": "J09", "descricao": "Influenza devida a v√≠rus identificado da gripe avi√°ria"},
            {"codigo": "J10", "descricao": "Influenza devida a outros v√≠rus da gripe identificados"},
            {"codigo": "J11", "descricao": "Influenza devida a v√≠rus n√£o identificado"},
            {"codigo": "J12", "descricao": "Pneumonia viral n√£o classificada em outra parte"},
            {"codigo": "J13", "descricao": "Pneumonia devida a Streptococcus pneumoniae"},
            {"codigo": "J14", "descricao": "Pneumonia devida a Haemophilus influenzae"},
            {"codigo": "J15", "descricao": "Pneumonia bacteriana n√£o classificada em outra parte"},
            {"codigo": "J18", "descricao": "Pneumonia por microorganismo n√£o especificado"},
            {"codigo": "J20", "descricao": "Bronquite aguda"},
            {"codigo": "J21", "descricao": "Bronquiolite aguda"},
            {"codigo": "J22", "descricao": "Infec√ß√£o aguda n√£o especificada das vias a√©reas inferiores"},
            {"codigo": "J40", "descricao": "Bronquite n√£o especificada como aguda ou cr√¥nica"},
            {"codigo": "J41", "descricao": "Bronquite cr√¥nica simples e a mucopurulenta"},
            {"codigo": "J42", "descricao": "Bronquite cr√¥nica n√£o especificada"},
            {"codigo": "J43", "descricao": "Enfisema"},
            {"codigo": "J44", "descricao": "Outras doen√ßas pulmonares obstrutivas cr√¥nicas"},
            {"codigo": "J45", "descricao": "Asma"},
            {"codigo": "J46", "descricao": "Estado de mal asm√°tico"},

            # Cardiovasculares (I00-I99)
            {"codigo": "I10", "descricao": "Hipertens√£o essencial"},
            {"codigo": "I11", "descricao": "Doen√ßa card√≠aca hipertensiva"},
            {"codigo": "I20", "descricao": "Angina pectoris"},
            {"codigo": "I21", "descricao": "Infarto agudo do mioc√°rdio"},
            {"codigo": "I22", "descricao": "Infarto do mioc√°rdio subseq√ºente"},
            {"codigo": "I25", "descricao": "Doen√ßa isqu√™mica cr√¥nica do cora√ß√£o"},
            {"codigo": "I50", "descricao": "Insufici√™ncia card√≠aca"},
            {"codigo": "I60", "descricao": "Hemorragia subaracn√≥ide"},
            {"codigo": "I61", "descricao": "Hemorragia intracerebral"},
            {"codigo": "I63", "descricao": "Infarto cerebral"},
            {"codigo": "I64", "descricao": "Acidente vascular cerebral n√£o especificado"},

            # Neoplasias (C00-D49)
            {"codigo": "C50", "descricao": "Neoplasia maligna da mama"},
            {"codigo": "C78", "descricao": "Neoplasia maligna secund√°ria dos √≥rg√£os respirat√≥rios e digestivos"},
            {"codigo": "C80", "descricao": "Neoplasia maligna sem especifica√ß√£o de localiza√ß√£o"},

            # Diabetes (E10-E14)
            {"codigo": "E10", "descricao": "Diabetes mellitus insulino-dependente"},
            {"codigo": "E11", "descricao": "Diabetes mellitus n√£o-insulino-dependente"},
            {"codigo": "E14", "descricao": "Diabetes mellitus n√£o especificado"},

            # Exemplos de outros cap√≠tulos
            {"codigo": "F32", "descricao": "Epis√≥dios depressivos"},
            {"codigo": "G20", "descricao": "Doen√ßa de Parkinson"},
            {"codigo": "K25", "descricao": "√ölcera g√°strica"},
            {"codigo": "N18", "descricao": "Doen√ßa renal cr√¥nica"},
        ]

        df = pd.DataFrame(cid_data)
        print(f"‚úÖ Base CID espec√≠fica criada com {len(df)} c√≥digos")
        return df

    def _initialize_semantic_search(self):
        """
        Inicializa modelo de embeddings para busca sem√¢ntica.
        """
        try:
            print("üîÑ Carregando modelo de embeddings...")
            # Usar modelo multil√≠ngue e compacto
            self.model = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')

            # Gerar embeddings das descri√ß√µes CID
            descriptions = self.cid_codes_df['descricao'].tolist()
            self.embeddings = self.model.encode(descriptions)

            print(f"‚úÖ Semantic search inicializado com {len(descriptions)} c√≥digos")

        except Exception as e:
            print(f"‚ùå Erro ao inicializar semantic search: {e}")
            self.model = None
            self.embeddings = None

    def find_cid_range(self, search_term: str) -> Optional[Tuple[str, str]]:
        """
        MESMA INTERFACE - Busca sem√¢ntica primeiro, fallback depois.
        """
        search_term_lower = search_term.lower().strip()
        print(f"üîç Buscando: '{search_term}'")

        # 1. BUSCA SEM√ÇNTICA (se dispon√≠vel)
        if self.model and self.embeddings is not None:
            semantic_result = self._semantic_search(search_term)
            if semantic_result:
                print(f"‚úÖ Encontrado via semantic search: {semantic_result}")
                return semantic_result

        # 2. BUSCA TEXTUAL na base CID espec√≠fica
        if self.cid_codes_df is not None:
            textual_result = self._textual_search(search_term_lower)
            if textual_result:
                print(f"‚úÖ Encontrado via busca textual: {textual_result}")
                return textual_result

        # 3. BUSCA HARDCODED (fallback original)
        hardcoded_result = self._hardcoded_search(search_term_lower)
        if hardcoded_result:
            print(f"‚úÖ Encontrado via hardcoded: {hardcoded_result}")
            return hardcoded_result

        print(f"‚ùå Termo '{search_term}' n√£o encontrado")
        return None

    def _semantic_search(self, search_term: str, top_k: int = 3, threshold: float = 0.6) -> Optional[Tuple[str, str]]:
        """
        Busca sem√¢ntica usando embeddings.
        """
        try:
            # Gerar embedding da query
            query_embedding = self.model.encode([search_term])

            # Calcular similaridades
            similarities = np.dot(query_embedding, self.embeddings.T).flatten()

            # Pegar os top_k mais similares
            top_indices = np.argsort(similarities)[-top_k:][::-1]
            best_similarity = similarities[top_indices[0]]

            if best_similarity > threshold:
                best_match_idx = top_indices[0]
                matched_code = self.cid_codes_df.iloc[best_match_idx]['codigo']
                matched_desc = self.cid_codes_df.iloc[best_match_idx]['descricao']

                print(f"   üéØ Melhor match: {matched_code} - {matched_desc}")
                print(f"   üìä Similaridade: {best_similarity:.3f}")

                # Retornar c√≥digo espec√≠fico como range
                return (matched_code, matched_code)

        except Exception as e:
            print(f"   ‚ùå Erro na busca sem√¢ntica: {e}")

        return None

    def _textual_search(self, search_term: str) -> Optional[Tuple[str, str]]:
        """
        Busca textual na base de c√≥digos espec√≠ficos.
        """
        if self.cid_codes_df is None:
            return None

        # Busca por substring na descri√ß√£o
        mask = self.cid_codes_df['descricao'].str.lower().str.contains(search_term, na=False)
        matches = self.cid_codes_df[mask]

        if not matches.empty:
            best_match = matches.iloc[0]  # Pegar o primeiro match
            code = best_match['codigo']
            desc = best_match['descricao']
            print(f"   üéØ Match textual: {code} - {desc}")
            return (code, code)

        # Busca por similaridade de string se n√£o encontrou substring
        best_similarity = 0
        best_code = None

        for _, row in self.cid_codes_df.iterrows():
            similarity = SequenceMatcher(None, search_term, row['descricao'].lower()).ratio()
            if similarity > best_similarity and similarity > 0.4:  # threshold m√≠nimo
                best_similarity = similarity
                best_code = row['codigo']

        if best_code:
            print(f"   üéØ Match por similaridade: {best_code} (sim: {best_similarity:.3f})")
            return (best_code, best_code)

        return None

    def _hardcoded_search(self, search_term: str) -> Optional[Tuple[str, str]]:
        """
        Busca hardcoded original (mantido como fallback).
        """
        # Busca exata
        if search_term in self.hardcoded_chapters:
            return self.hardcoded_chapters[search_term]

        # Busca parcial
        for key, value in self.hardcoded_chapters.items():
            if search_term in key or key in search_term:
                return value

        # Busca por palavras
        words = search_term.split()
        for word in words:
            if len(word) > 3:
                for key, value in self.hardcoded_chapters.items():
                    if word in key:
                        return value

        return None

    def search_detailed(self, search_term: str, max_results: int = 5) -> List[Dict]:
        """
        NOVA FUN√á√ÉO: Retorna resultados detalhados da busca sem√¢ntica.
        """
        results = []

        if self.model and self.embeddings is not None:
            try:
                query_embedding = self.model.encode([search_term])
                similarities = np.dot(query_embedding, self.embeddings.T).flatten()

                # Top resultados
                top_indices = np.argsort(similarities)[-max_results:][::-1]

                for idx in top_indices:
                    if similarities[idx] > 0.3:  # threshold m√≠nimo
                        row = self.cid_codes_df.iloc[idx]
                        results.append({
                            'codigo': row['codigo'],
                            'descricao': row['descricao'],
                            'similaridade': float(similarities[idx])
                        })

            except Exception as e:
                print(f"Erro na busca detalhada: {e}")

        return results

    # Mant√©m m√©todos existentes para compatibilidade
    def get_available_categories(self) -> Dict[str, Tuple[str, str]]:
        """Retorna categorias hardcoded (compatibilidade)."""
        return self.hardcoded_chapters.copy()

    def search_suggestions(self, search_term: str) -> List[str]:
        """Sugest√µes melhoradas usando semantic search."""
        if self.model:
            detailed_results = self.search_detailed(search_term, max_results=3)
            return [f"{r['codigo']}: {r['descricao']}" for r in detailed_results]
        else:
            # Fallback original
            suggestions = []
            search_term_lower = search_term.lower()
            for key in self.hardcoded_chapters.keys():
                if any(word in key for word in search_term_lower.split() if len(word) > 2):
                    suggestions.append(key)
            return suggestions[:5]


# Demonstra√ß√£o e teste
def demonstrar_melhorias():
    """
    Demonstra as melhorias da busca sem√¢ntica vs. hardcoded.
    """
    print("üß™ DEMONSTRA√á√ÉO: BUSCA SEM√ÇNTICA vs HARDCODED")
    print("=" * 60)

    lookup = CIDLookup()

    test_cases = [
        # Casos que semantic search resolve melhor
        "falta de ar",  # ‚Üí J44 (DPOC) via semantic, vs gen√©rico J00-J99
        "dor no peito",  # ‚Üí I20 (angina) via semantic
        "tosse persistente",  # ‚Üí J40 (bronquite) via semantic
        "press√£o alta",  # ‚Üí I10 (hipertens√£o) via semantic
        "a√ß√∫car no sangue",  # ‚Üí E11 (diabetes) via semantic

        # Casos que ambos funcionam
        "pneumonia",  # Ambos funcionam
        "asma",  # Ambos funcionam
        "diabetes",  # Ambos funcionam

        # Casos edge
        "covid",  # Teste para novos termos
        "depress√£o",  # Teste para sa√∫de mental
    ]

    for term in test_cases:
        print(f"\nüîç Testando: '{term}'")
        print("-" * 30)

        result = lookup.find_cid_range(term)
        if result:
            print(f"‚úÖ Resultado: {result[0]}-{result[1]}")

            # Mostrar detalhes se semantic search dispon√≠vel
            if lookup.model:
                detailed = lookup.search_detailed(term, max_results=2)
                for detail in detailed:
                    print(f"   üìã {detail['codigo']}: {detail['descricao']} (sim: {detail['similaridade']:.3f})")
        else:
            print("‚ùå N√£o encontrado")


if __name__ == "__main__":
    demonstrar_melhorias()